<#@ output extension=".cs" #>
<#@ assembly name="System" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Linq" #>
<#@ assembly name="System.Collections" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#
    const int PARAMETER_COUNT = 15;

    IEnumerable<string> GetParameterTypes(int count)
    {
        for(int i = 1; i <= count; i++)
        {
            yield return $"TParameter{i}";
        }
    }

    IEnumerable<string> GetParameterNames(int count)
    {
        for(int i = 1; i <= count; i++)
        {
            yield return $"parameter{i}";
        }
    }

    IEnumerable<string> GetParameterRole(int count, int variation)
    {
        for(int i = 1; i <= count; i++)
        {
            if (IsVariationIndexOut(variation, i))
            {
                yield return $"out ";
            }
            else 
            {
                yield return $"";
            }
        }
    }

    IEnumerable<string> GetTypeParameterRole(int count, int variation)
    {
        for(int i = 1; i <= count; i++)
        {
            if (IsVariationIndexOut(variation, i))
            {
                yield return $"";
            }
            else 
            {
                yield return $"in ";
            }
        }
    }

    bool IsVariationIndexOut(int variation, int index)
    {
        return (variation & index) != 0;
    }
        
    string GetParameterTypesString(int count)
    {
        var types = GetParameterTypes(count).ToArray();
        var parameters = new List<string>();
        for(int i = 0; i < types.Length; i++)
        {
            parameters.Add($"{types[i]}");
        }

        return String.Join(", ", parameters);
    }
        
    string GetParameterTypesStringWithRoles(int count, int variation)
    {
        var types = GetParameterTypes(count).ToArray();
        var roles = GetTypeParameterRole(count, variation).ToArray();
        var parameters = new List<string>();
        for(int i = 0; i < types.Length; i++)
        {
            parameters.Add($"{roles[i]}{types[i]}");
        }

        return String.Join(", ", parameters);
    }
        
    string GetParameterTypedNamesString(int count, int variation)
    {
        var types = GetParameterTypes(count).ToArray();
        var names = GetParameterNames(count).ToArray();
        var roles = GetParameterRole(count, variation).ToArray();
        var parameters = new List<string>();
        for(int i = 0; i < types.Length; i++)
        {
            parameters.Add($"{roles[i]}{types[i]} {names[i]}");
        }

        return String.Join(", ", parameters);
    }


#>
using System;
using System.Linq.Expressions;

namespace Moq.CompactSetup
{
    /// <summary>
    /// The mock extensions class part for value selector functions.
    /// </summary>
    public static partial class MockExtensions
    {
<#
    for(int i = 0; i <= PARAMETER_COUNT; i++) 
    {
        if (i > 0)
        {
            var startVariation = 1; // Skip the first, as the first is just no out parameter.
            var maxVariations = (int)Math.Pow(2, i);
            for(int variation = 1; variation < maxVariations; variation++)
            {        
#>
<#
            }
        }
#>
        /// <summary>
        /// Sets up a member with the specified value selector.
        /// </summary>
        /// <typeparam name="TMockable"> The type of the mockable class or interface. </typeparam>
<#          for(int j = 1; j <= i; j++) { #>
        /// <typeparam name="TParameter<#=j#>"> The type of the <#=j#>. parameter. </typeparam>
<#          } #>
        /// <typeparam name="TResult"> The type of the return type. </typeparam>
        /// <param name="mock"> The mock. </param>
        /// <param name="memberExpression"> The member expression to set up. </param>
        /// <param name="valueSelector"> The function returning the value for specified parameters. </param>
        /// <returns> The same mock again. </returns>
        /// <exception cref="ArgumentNullException"> When <paramref name="mock" />, <paramref name="memberExpression" /> or <paramref name="valueSelector" /> is <see langword="null" />. </exception>
        public static Mock<TMockable> With<TMockable, <#=GetParameterTypesString(i)#><#=(i > 0 ? ", " : "")#>TResult>(this Mock<TMockable> mock, Expression<Func<TMockable, TResult>> memberExpression, Func<<#=GetParameterTypesString(i)#><#=(i > 0 ? ", " : "")#>TResult> valueSelector)
            where TMockable : class
        {
            if (mock == null)
            {
                throw new ArgumentNullException(nameof(mock));
            }

            if (memberExpression == null)
            {
                throw new ArgumentNullException(nameof(memberExpression));
            }

            if (valueSelector == null)
            {
                throw new ArgumentNullException(nameof(valueSelector));
            }

            mock.Setup(memberExpression).Returns(valueSelector);
            return mock;
        }

<#
    }
#>  
    }
} 