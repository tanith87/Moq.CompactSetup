<#@ output extension=".cs" #>
<#@ assembly name="System" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Linq" #>
<#@ assembly name="System.Collections" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#
    const int PARAMETER_COUNT = 4;

    IEnumerable<string> GetParameterTypes(int count)
    {
        for(int i = 1; i <= count; i++)
        {
            yield return $"TParameter{i}";
        }
    }

    IEnumerable<string> GetParameterNames(int count)
    {
        for(int i = 1; i <= count; i++)
        {
            yield return $"parameter{i}";
        }
    }

    IEnumerable<string> GetParameterRole(int count, int variation)
    {
        for(int i = 1; i <= count; i++)
        {
            if (IsVariationIndexOut(variation, i))
            {
                yield return $"out ";
            }
            else 
            {
                yield return $"";
            }
        }
    }

    IEnumerable<string> GetTypeParameterRole(int count, int variation)
    {
        for(int i = 1; i <= count; i++)
        {
            if (IsVariationIndexOut(variation, i))
            {
                yield return $"";
            }
            else 
            {
                yield return $"in ";
            }
        }
    }

    bool IsVariationIndexOut(int variation, int index)
    {
        return (variation & index) != 0;
    }
        
    string GetParameterTypesString(int count)
    {
        var types = GetParameterTypes(count).ToArray();
        var parameters = new List<string>();
        for(int i = 0; i < types.Length; i++)
        {
            parameters.Add($"{types[i]}");
        }

        return String.Join(", ", parameters);
    }
        
    string GetParameterTypesStringWithRoles(int count, int variation)
    {
        var types = GetParameterTypes(count).ToArray();
        var roles = GetTypeParameterRole(count, variation).ToArray();
        var parameters = new List<string>();
        for(int i = 0; i < types.Length; i++)
        {
            parameters.Add($"{roles[i]}{types[i]}");
        }

        return String.Join(", ", parameters);
    }
        
    string GetParameterTypedNamesString(int count, int variation)
    {
        var types = GetParameterTypes(count).ToArray();
        var names = GetParameterNames(count).ToArray();
        var roles = GetParameterRole(count, variation).ToArray();
        var parameters = new List<string>();
        for(int i = 0; i < types.Length; i++)
        {
            parameters.Add($"{roles[i]}{types[i]} {names[i]}");
        }

        return String.Join(", ", parameters);
    }


#>
using Moq.Language;
using Moq.Language.Flow;

namespace Moq.CompactSetup
{
<#
    for(int i = 1; i <= PARAMETER_COUNT; i++) 
    {
        var startVariation = 1; // Skip the first, as the first is just no out parameter.
        var maxVariations = (int)Math.Pow(2, i);
        for(int variation = 1; variation < maxVariations; variation++)
        {
#>
    /// <summary>
    /// The signature for a method with in and out parameters.
    /// </summary>
<#          for(int j = 1; j <= i; j++) { #>
    /// <typeparam name="TParameter<#=j#>"> The type of the <#=j#>. parameter. </typeparam>
<#          } #>
<#          for(int j = 1; j <= i; j++) { #>
    /// <param name="parameter<#=j#>"> The <#=j#>. parameter. </param>
<#          } #>
    public delegate void Out<#=i#>Action<#=variation#><<#=GetParameterTypesStringWithRoles(i, variation)#>>(<#=GetParameterTypedNamesString(i, variation)#>);

<#
        }
    }
#>  
    /// <summary>
    /// The extension class for Moq callbacks.
    /// </summary>
    internal static partial class CallbackExtensions
    {
<#
    for(int i = 1; i <= PARAMETER_COUNT; i++) 
    {
        var startVariation = 1; // Skip the first, as the first is just no out parameter.
        var maxVariations = (int)Math.Pow(2, i);
        for(int variation = 1; variation < maxVariations; variation++)
        {
#>
        /// <summary>
        /// Applies the callback called.
        /// </summary>
        /// <typeparam name="TMock"> The type of the mock. </typeparam>
        /// <typeparam name="TReturn"> The type of the return. </typeparam>
<#          for(int j = 1; j <= i; j++) { #>
        /// <typeparam name="TParameter<#=j#>"> The type of the <#=j#>. parameter. </typeparam>
<#          } #>
        /// <param name="mock"> The mock. </param>
        /// <param name="action"> The action. </param>
        /// <returns> The return handler. </returns>
        public static IReturnsThrows<TMock, TReturn> OutCallback<TMock, TReturn, <#=GetParameterTypesString(i)#>>(this ICallback<TMock, TReturn> mock, Out<#=i#>Action<#=variation#><<#=GetParameterTypesString(i)#>> action)
            where TMock : class
        {
            return SetOutCallback(mock, action);
        }

        /// <summary>
        /// Applies the callback called without return value.
        /// </summary>
<#          for(int j = 1; j <= i; j++) { #>
        /// <typeparam name="TParameter<#=j#>"> The type of the <#=j#>. parameter. </typeparam>
<#          } #>
        /// <param name="mock"> The mock. </param>
        /// <param name="action"> The action. </param>
        /// <returns> The callback result. </returns>
        public static ICallbackResult OutCallback<<#=GetParameterTypesString(i)#>>(this ICallback mock, Out<#=i#>Action<#=variation#><<#=GetParameterTypesString(i)#>> action)
        {
            return SetOutCallback(mock, action);
        }

<#
        }
    }
#>  
    }
} 